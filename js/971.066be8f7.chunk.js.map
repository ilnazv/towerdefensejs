{"version":3,"file":"js/971.066be8f7.chunk.js","mappings":"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","sources":["webpack://towerdefensejs/./src/game/Constants.ts","webpack://towerdefensejs/./src/game/Components/Towers/Models.ts","webpack://towerdefensejs/./src/game/Components/Path.ts","webpack://towerdefensejs/./src/game/Models.ts","webpack://towerdefensejs/./src/game/Components/Towers/Towers.ts","webpack://towerdefensejs/./src/game/Utils.ts","webpack://towerdefensejs/./src/game/Components/Canvas.ts","webpack://towerdefensejs/./src/game/Components/CommandBar.ts","webpack://towerdefensejs/./src/game/Components/BasicElements/Button.ts","webpack://towerdefensejs/./src/game/Components/Projectile.ts","webpack://towerdefensejs/./src/game/Components/Enemies/Enemy.ts","webpack://towerdefensejs/./src/game/Game.ts"],"sourcesContent":["export const defaultBlockSize = 10;\r\nexport class ElelementsIds {\r\n    static logsElId = 'logs';\r\n    static toggleLogsButtonId = 'toggleLogs';\r\n    static canvasId = 'gameCanvas';\r\n}\r\n","import { IDrawable, IClickable } from '../../Models';\r\nimport { Enemy } from '../Enemies/Enemy';\r\n\r\nexport interface ITower extends IDrawable, IClickable {\r\n    attack(enemies: Enemy[]): void;\r\n}\r\n\r\nexport interface ITowerParams {\r\n    damageStart: number;\r\n    damageEnd: number;\r\n    attackRange: number;\r\n    attackSpeed: number;\r\n}\r\n\r\nexport enum TowerType {\r\n    SpearTower = 'SpearTower',\r\n    SplashTower = 'SplashTower',\r\n}\r\n","import { IDrawable, IPoint } from '../Models';\r\n\r\nexport class Path implements IDrawable {\r\n    private percentPathMap = new Map<{ start: number; end: number }, number>();\r\n    private length = 0;\r\n\r\n    constructor(public points: IPoint[], public color = 'gray') {\r\n        this.calculateSections();\r\n    }\r\n\r\n    private calculateSections(): void {\r\n        for (let index = 1; index < this.points.length; index++) {\r\n            const point = this.points[index];\r\n            const prevPoint = this.points[index - 1];\r\n            const start = this.length;\r\n            this.length += Math.abs(\r\n                prevPoint.x - point.x + (prevPoint.y - point.y)\r\n            );\r\n            this.percentPathMap.set(\r\n                {\r\n                    start,\r\n                    end: this.length,\r\n                },\r\n                index\r\n            );\r\n        }\r\n    }\r\n\r\n    public getPointAtPercent(percent: number): IPoint {\r\n        const step = (this.length / 100) * percent;\r\n        const sections = [...Array.from(this.percentPathMap.keys())];\r\n        const sectionKey = sections.find(\r\n            ({ start, end }) => step >= start && step <= end\r\n        );\r\n        const section = this.percentPathMap.get(sectionKey);\r\n        if (!section) {\r\n            return null;\r\n        }\r\n        const sectionPercent =\r\n            (step - sectionKey.start) /\r\n            ((sectionKey.end - sectionKey.start) / 100) /\r\n            100;\r\n        const point = this.points[section];\r\n        const prevPoint = this.points[section - 1];\r\n        var dx = point.x - prevPoint.x;\r\n        var dy = point.y - prevPoint.y;\r\n        var X = prevPoint.x + dx * sectionPercent;\r\n        var Y = prevPoint.y + dy * sectionPercent;\r\n        return { x: Math.round(X), y: Math.round(Y) };\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D): void {\r\n        ctx.save();\r\n        ctx.fillStyle = this.color;\r\n        ctx.beginPath();\r\n        ctx.setLineDash([5, 15]);\r\n        ctx.lineCap = 'round';\r\n        for (let index = 0; index < this.points.length; index++) {\r\n            const point = this.points[index];\r\n            if (index === 0) {\r\n                ctx.moveTo(point.x, point.y);\r\n            } else {\r\n                ctx.lineTo(point.x, point.y);\r\n            }\r\n        }\r\n        ctx.stroke();\r\n        ctx.restore();\r\n        this.drawStartEnd(ctx);\r\n    }\r\n\r\n    private drawStartEnd(ctx: CanvasRenderingContext2D): void {\r\n        ctx.beginPath();\r\n        ctx.fillStyle = 'orange';\r\n        ctx.arc(this.points[0].x, this.points[0].y, 10, 0, 360);\r\n        ctx.arc(\r\n            this.points[this.points.length - 1].x,\r\n            this.points[this.points.length - 1].y,\r\n            10,\r\n            0,\r\n            360\r\n        );\r\n        ctx.fill();\r\n        ctx.closePath();\r\n    }\r\n}\r\n","export interface IPoint {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport class PointHelper {\r\n    static pointInsideRect(\r\n        point: IPoint,\r\n        rectCenter: IPoint,\r\n        size: ISize\r\n    ): boolean {\r\n        const xInside =\r\n            point.x >= rectCenter.x - size.width / 2 &&\r\n            point.x <= rectCenter.x + size.width / 2;\r\n        const yInside =\r\n            point.y >= rectCenter.y - size.width / 2 &&\r\n            point.y <= rectCenter.y + size.width / 2;\r\n        return xInside && yInside;\r\n    }\r\n\r\n    static pointInsideCircle(\r\n        point: IPoint,\r\n        circleCenter: IPoint,\r\n        radius: number\r\n    ): boolean {\r\n        return (\r\n            Math.sqrt(\r\n                (point.x - circleCenter.x) ** 2 +\r\n                    (point.y - circleCenter.y) ** 2\r\n            ) < radius\r\n        );\r\n    }\r\n}\r\n\r\nexport interface IDrawable {\r\n    draw(ctx: CanvasRenderingContext2D, color?: string): void;\r\n}\r\n\r\nexport interface IClickable {\r\n    onClickHandler(ctx: CanvasRenderingContext2D, point: IPoint): void;\r\n    pointInPath(ctx: CanvasRenderingContext2D, point: IPoint): boolean;\r\n}\r\n\r\nexport function getRandomArbitrary(min: number, max: number): number {\r\n    return Math.random() * (max - min) + min;\r\n}\r\n\r\nexport interface ISize {\r\n    width: number;\r\n    height: number;\r\n}\r\n\r\nexport interface IWaveSettings {\r\n    enemiesNumber: number;\r\n    enemiesMoveSpeed: number;\r\n    enemiesColor: string;\r\n    spawnSpeed: number;\r\n}\r\n","import { TowerType, ITowerParams, ITower } from './Models';\r\nimport {\r\n    IDrawable,\r\n    IPoint,\r\n    getRandomArbitrary,\r\n    PointHelper,\r\n} from '../../Models';\r\nimport { defaultBlockSize } from '../../Constants';\r\nimport { Enemy } from '../Enemies/Enemy';\r\n\r\nexport class Item implements IDrawable {\r\n    constructor(\r\n        public position: IPoint,\r\n        private blockSize = defaultBlockSize,\r\n        public color = 'black'\r\n    ) {}\r\n\r\n    get x(): number {\r\n        return this.position.x;\r\n    }\r\n\r\n    get y(): number {\r\n        return this.position.y;\r\n    }\r\n\r\n    get leftTopX(): number {\r\n        return this.position.x - this.blockSize / 2;\r\n    }\r\n\r\n    get leftTopY(): number {\r\n        return this.position.y - this.blockSize / 2;\r\n    }\r\n\r\n    get leftTop(): IPoint {\r\n        return {\r\n            x: this.leftTopX,\r\n            y: this.leftTopY,\r\n        };\r\n    }\r\n\r\n    get width(): number {\r\n        return this.blockSize;\r\n    }\r\n\r\n    get height(): number {\r\n        return this.blockSize;\r\n    }\r\n\r\n    public moveTo(point: IPoint) {\r\n        this.position = point;\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D, color = this.color): void {\r\n        throw new Error('not implemented');\r\n    }\r\n}\r\n\r\nexport const getTowerParams = (\r\n    type: TowerType,\r\n    level: number\r\n): ITowerParams => {\r\n    switch (type) {\r\n        case TowerType.SpearTower:\r\n            return {\r\n                damageStart: 45,\r\n                damageEnd: 65,\r\n                attackRange: 100,\r\n                attackSpeed: 5,\r\n            };\r\n        case TowerType.SplashTower:\r\n            return {\r\n                damageStart: 20,\r\n                damageEnd: 40,\r\n                attackRange: 50,\r\n                attackSpeed: 2,\r\n            };\r\n    }\r\n};\r\n\r\nexport class TowerFactory {\r\n    static createTower(\r\n        position: IPoint,\r\n        type: TowerType,\r\n        level: number\r\n    ): ITower {\r\n        switch (type) {\r\n            case TowerType.SpearTower:\r\n                const towerParams = getTowerParams(type, level);\r\n                return new SpearTowerBase(position, towerParams);\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nexport class SpearTowerBase extends Item implements ITower {\r\n    public damageStart = 45;\r\n    public damageEnd = 65;\r\n    public attackRange = 100;\r\n    public attackSpeed = 5;\r\n    private attackCounter = 100;\r\n\r\n    private get damage(): number {\r\n        return getRandomArbitrary(this.damageStart, this.damageEnd);\r\n    }\r\n\r\n    private path: Path2D;\r\n\r\n    constructor(\r\n        position: IPoint,\r\n        params: ITowerParams,\r\n        blockSize = defaultBlockSize,\r\n        color = 'blue'\r\n    ) {\r\n        super(position, blockSize, color);\r\n        const { attackRange, attackSpeed, damageEnd, damageStart } = params;\r\n        this.damageStart = damageStart;\r\n        this.damageEnd = damageEnd;\r\n        this.attackRange = attackRange;\r\n        this.attackSpeed = attackSpeed;\r\n    }\r\n    onClickHandler(ctx: CanvasRenderingContext2D, point: IPoint): void {\r\n        return;\r\n    }\r\n    pointInPath(ctx: CanvasRenderingContext2D, point: IPoint): boolean {\r\n        return ctx.isPointInPath(this.path, point.x, point.y);\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D, color = this.color): void {\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.fillStyle = color;\r\n        this.path = new Path2D();\r\n        this.path.arc(this.leftTopX, this.leftTopY, this.width, 0, 360);\r\n        ctx.fill(this.path);\r\n        ctx.closePath();\r\n        this.drawAttackRange(ctx);\r\n        ctx.restore();\r\n    }\r\n\r\n    private drawAttackRange(ctx: CanvasRenderingContext2D): void {\r\n        ctx.beginPath();\r\n        ctx.setLineDash([5, 15]);\r\n        ctx.fillStyle = 'gray';\r\n        ctx.arc(this.leftTopX, this.leftTopY, this.attackRange, 0, 360);\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n    }\r\n\r\n    public attack(enemies: Enemy[]): void {\r\n        if (this.attackCounter <= 100) {\r\n            this.attackCounter += this.attackSpeed;\r\n            return;\r\n        }\r\n        for (let index = 0; index < enemies.length; index++) {\r\n            const enemy = enemies[index];\r\n            if (\r\n                !enemy.dead &&\r\n                PointHelper.pointInsideCircle(\r\n                    enemy,\r\n                    this.position,\r\n                    this.attackRange\r\n                )\r\n            ) {\r\n                enemy.shootAt(this.damage, this.position);\r\n                // console.log('enemy hp:', enemy.hp);\r\n                this.attackCounter = 0;\r\n                return;\r\n            }\r\n        }\r\n        this.attackCounter = 0;\r\n    }\r\n}\r\n","import { ElelementsIds } from './Constants';\r\n\r\nconst logsEl = document.getElementById(ElelementsIds.logsElId);\r\n\r\nexport const log = (msg: string): void => {\r\n    if (logsEl) {\r\n        logsEl.innerHTML = msg + '\\n' + logsEl.innerHTML;\r\n    }\r\n};\r\n","import { IDrawable, IPoint, ISize, IClickable } from '../Models';\r\nimport { Item } from './Towers/Towers';\r\nimport { ITower } from './Towers/Models';\r\nimport { log } from '../Utils';\r\n\r\nexport class Canvas {\r\n    public emptyColor = 'white';\r\n    private items: IDrawable[] = [];\r\n\r\n    private dragItem: Item;\r\n\r\n    private _dragNDropDisabled = false;\r\n\r\n    public DisableDragNDrop(): void {\r\n        this._dragNDropDisabled = true;\r\n    }\r\n\r\n    public EnabledDragNDrop(): void {\r\n        this._dragNDropDisabled = false;\r\n    }\r\n\r\n    private handleMousedown(ev: MouseEvent): void {\r\n        const point: IPoint = {\r\n            x: ev.offsetX,\r\n            y: ev.offsetY,\r\n        };\r\n        this.dragItem = this._dragNDropDisabled ? undefined : this.items\r\n            .filter((x) => ((x as unknown) as ITower).pointInPath)\r\n            .find((x) =>\r\n                ((x as unknown) as ITower).pointInPath(this.ctx, point)\r\n            ) as Item;\r\n    }\r\n\r\n    private handleTouchstart(ev: TouchEvent): void {\r\n        const touchPoint = ev.touches.length && ev.touches[0];\r\n        const point: IPoint = {\r\n            x: touchPoint.pageX - this.htmlCanvas.offsetLeft,\r\n            y: touchPoint.pageY - this.htmlCanvas.offsetTop,\r\n        };\r\n        log(`handleTouchstart: ${JSON.stringify(point)}`);\r\n        this.handleOnClick(point);\r\n        this.dragItem = this.items\r\n            .filter((x) => ((x as unknown) as ITower).pointInPath)\r\n            .find((x) =>\r\n                ((x as unknown) as ITower).pointInPath(this.ctx, point)\r\n            ) as Item;\r\n    }\r\n\r\n    private handleMousemove(ev: MouseEvent): void {\r\n        const coords: IPoint = {\r\n            x: ev.offsetX,\r\n            y: ev.offsetY,\r\n        };\r\n        if (this.dragItem) {\r\n            this.dragItem.moveTo(coords);\r\n            this.update();\r\n        }\r\n    }\r\n\r\n    private handleTouchmove(ev: TouchEvent): void {\r\n        const touchPoint = ev.touches.length && ev.touches[0];\r\n        const coords: IPoint = {\r\n            x: touchPoint.pageX - this.htmlCanvas.offsetLeft,\r\n            y: touchPoint.pageY - this.htmlCanvas.offsetTop,\r\n        };\r\n        if (this.dragItem) {\r\n            this.dragItem.moveTo(coords);\r\n            this.update();\r\n        }\r\n    }\r\n\r\n    private handleMouseup(_ev: MouseEvent): void {\r\n        this.dragItem = undefined;\r\n    }\r\n\r\n    private handleTouchend(_ev: TouchEvent): void {\r\n        this.dragItem = undefined;\r\n    }\r\n\r\n    private handleMouseClicks(ev: MouseEvent): void {\r\n        this.handleOnClick({\r\n            x: ev.offsetX,\r\n            y: ev.offsetY,\r\n        });\r\n    }\r\n\r\n    private setSize({ width, height }: ISize = { width: window.innerWidth, height: window.innerHeight }): void {\r\n        this.htmlCanvas.width = width;\r\n        this.htmlCanvas.height = height;\r\n    }\r\n\r\n    public get size(): ISize {\r\n        return {\r\n            height: this.htmlCanvas.height,\r\n            width: this.htmlCanvas.width,\r\n        };\r\n    }\r\n\r\n    constructor(private htmlCanvas: HTMLCanvasElement) {\r\n        htmlCanvas.addEventListener('mousedown', (ev) =>\r\n            this.handleMousedown(ev)\r\n        );\r\n        htmlCanvas.addEventListener('touchstart', (ev) =>\r\n            this.handleTouchstart(ev)\r\n        );\r\n        htmlCanvas.addEventListener('mousemove', (ev) =>\r\n            this.handleMousemove(ev)\r\n        );\r\n        htmlCanvas.addEventListener('touchmove', (ev) =>\r\n            this.handleTouchmove(ev)\r\n        );\r\n        htmlCanvas.addEventListener('mouseup', (ev) =>\r\n            this.handleMouseup(ev as MouseEvent)\r\n        );\r\n        htmlCanvas.addEventListener('touchend', (ev) =>\r\n            this.handleTouchend(ev)\r\n        );\r\n        htmlCanvas.addEventListener('click', (ev) =>\r\n            this.handleMouseClicks(ev)\r\n        );\r\n        this.setSize({\r\n            height: 400,\r\n            width: 600\r\n        });\r\n    }\r\n\r\n    private get ctx(): CanvasRenderingContext2D {\r\n        return this.htmlCanvas.getContext('2d') as CanvasRenderingContext2D;\r\n    }\r\n\r\n    public add(...items: IDrawable[]): void {\r\n        this.items.push(...items);\r\n    }\r\n\r\n    public remove(...items: IDrawable[]): void {\r\n        this.items = this.items.filter((x) => !items.includes(x));\r\n    }\r\n\r\n    public update(): void {\r\n        this.ctx.fillStyle = this.emptyColor;\r\n        this.ctx.clearRect(0, 0, this.size.width, this.size.height);\r\n        for (let index = 0; index < this.items.length; index++) {\r\n            const item = this.items[index];\r\n            item.draw(this.ctx);\r\n        }\r\n    }\r\n\r\n    public handleOnClick(point: IPoint): void {\r\n        this.items\r\n            .filter((x) => ((x as unknown) as IClickable).onClickHandler)\r\n            .forEach((x) =>\r\n                ((x as unknown) as IClickable).onClickHandler(this.ctx, point)\r\n            );\r\n    }\r\n}\r\n","import { IDrawable, ISize } from '../Models';\r\n\r\nexport class CommandBar implements IDrawable {\r\n    private readonly barHeight = 100;\r\n    constructor(private canvasSize: ISize) {}\r\n\r\n    draw(ctx: CanvasRenderingContext2D, color?: string): void {\r\n        ctx.fillStyle = 'green';\r\n        ctx.fillRect(0, 0, this.canvasSize.width, this.barHeight);\r\n        this.drawMenuItems();\r\n    }\r\n\r\n    private drawMenuItems(): void {}\r\n}\r\n","import { IDrawable, IClickable, IPoint } from '../../Models';\r\nimport { IButtonParams } from './Models';\r\n\r\nexport class Button implements IDrawable, IClickable {\r\n    private path: Path2D;\r\n    constructor(\r\n        public text: string,\r\n        public onClick: () => void,\r\n        private params: IButtonParams = {\r\n            buttonHeight: 50,\r\n            buttonWidth: 100,\r\n            leftTopX: 1,\r\n            leftTopY: 2,\r\n        }\r\n    ) {}\r\n\r\n    pointInPath(ctx: CanvasRenderingContext2D, point: IPoint): boolean {\r\n        return ctx.isPointInPath(this.path, point.x, point.y);\r\n    }\r\n\r\n    onClickHandler(ctx: CanvasRenderingContext2D, point: IPoint): void {\r\n        if (this.pointInPath(ctx, point)) {\r\n            if (this.onClick) {\r\n                this.onClick();\r\n            }\r\n        }\r\n    }\r\n\r\n    draw(ctx: CanvasRenderingContext2D, color = '#A9B665'): void {\r\n        const radgrad = ctx.createRadialGradient(\r\n            this.params.leftTopX + 45,\r\n            this.params.leftTopY + 45,\r\n            10,\r\n            this.params.leftTopX + 52,\r\n            this.params.leftTopY + 50,\r\n            100\r\n        );\r\n        radgrad.addColorStop(0, '#A7D30C');\r\n        radgrad.addColorStop(1, '#019F62');\r\n        ctx.fillStyle = radgrad;\r\n        this.path = new Path2D();\r\n        this.path.rect(\r\n            this.params.leftTopX,\r\n            this.params.leftTopY,\r\n            this.params.buttonWidth,\r\n            this.params.buttonHeight\r\n        );\r\n        ctx.fill(this.path);\r\n        ctx.font = '20px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillStyle = 'black';\r\n        ctx.fillText(\r\n            this.text,\r\n            this.params.leftTopX + this.params.buttonWidth / 2,\r\n            this.params.leftTopY + this.params.buttonHeight / 2\r\n        );\r\n    }\r\n}\r\n","import { IDrawable, IPoint } from '../Models';\r\nimport { Enemy } from './Enemies/Enemy';\r\n\r\nexport class Projectile implements IDrawable {\r\n    private progress = 0;\r\n    private speed = 0.3;\r\n\r\n    constructor(\r\n        public dmg: number,\r\n        private position: IPoint,\r\n        private target: Enemy\r\n    ) {}\r\n\r\n    public draw(ctx: CanvasRenderingContext2D, color = 'green'): void {\r\n        ctx.beginPath();\r\n        ctx.fillStyle = color;\r\n        ctx.arc(this.position.x, this.position.y, 2, 0, 360);\r\n        ctx.fill();\r\n        ctx.closePath();\r\n    }\r\n\r\n    public moveForward(): boolean {\r\n        const targetPosition = this.target.position;\r\n        var dx = targetPosition.x - this.position.x;\r\n        var dy = targetPosition.y - this.position.y;\r\n        var X = this.position.x + dx * this.progress;\r\n        var Y = this.position.y + dy * this.progress;\r\n        this.position = { x: Math.round(X), y: Math.round(Y) };\r\n        this.progress += this.speed;\r\n        return this.progress >= 1;\r\n    }\r\n}\r\n","import { Item } from '../Towers/Towers';\r\nimport { Projectile } from '../Projectile';\r\nimport { Path } from '../Path';\r\nimport { defaultBlockSize } from '../../Constants';\r\nimport { IPoint } from '../../Models';\r\n\r\nexport class Enemy extends Item {\r\n    private progress = 0;\r\n    private _dead = false;\r\n    private _healthPoints = 100;\r\n\r\n    private projectiles: Projectile[] = [];\r\n\r\n    get dead(): boolean {\r\n        return this._dead;\r\n    }\r\n\r\n    get hp(): number {\r\n        return this._healthPoints;\r\n    }\r\n\r\n    constructor(\r\n        private path: Path,\r\n        private moveSpeed = 0.3,\r\n        blockSize = defaultBlockSize,\r\n        color = 'red'\r\n    ) {\r\n        super(path.points[0], blockSize, color);\r\n    }\r\n\r\n    public shootAt(dmg: number, towerPosition: IPoint): void {\r\n        this.projectiles.push(new Projectile(dmg, towerPosition, this));\r\n    }\r\n\r\n    public doDamage(dmg: number): void {\r\n        this._healthPoints -= dmg;\r\n        if (this._healthPoints <= 0) {\r\n            this._dead = true;\r\n        }\r\n    }\r\n\r\n    public draw(ctx: CanvasRenderingContext2D, color = this.color): void {\r\n        if (this.dead) {\r\n            ctx.fillStyle = 'gray';\r\n        } else {\r\n            ctx.fillStyle = color;\r\n        }\r\n        const rect = new Path2D();\r\n        rect.rect(this.leftTopX, this.leftTopY, this.width, this.height);\r\n        ctx.fill(rect);\r\n        this.projectiles.forEach((x) => x.draw(ctx));\r\n    }\r\n\r\n    public moveForward(): boolean {\r\n        const reachedProjectiles = this.projectiles.filter((x) =>\r\n            x.moveForward()\r\n        );\r\n        if (reachedProjectiles.length > 0) {\r\n            reachedProjectiles.forEach((x) => this.doDamage(x.dmg));\r\n            this.projectiles = this.projectiles.filter(\r\n                (x) => !reachedProjectiles.includes(x)\r\n            );\r\n        }\r\n        if (this.dead) {\r\n            return false;\r\n        }\r\n        const nextPoint = this.path.getPointAtPercent(this.progress);\r\n        if (!nextPoint) {\r\n            return;\r\n        }\r\n        this.moveTo(nextPoint);\r\n        if (this.progress >= 100) {\r\n            return true;\r\n        }\r\n        if (this.progress + this.moveSpeed > 100) {\r\n            this.progress = 100;\r\n            return true;\r\n        }\r\n        this.progress += this.moveSpeed;\r\n        return false;\r\n    }\r\n}\r\n","import { Path } from './Components/Path';\r\nimport { ITower, TowerType } from './Components/Towers/Models';\r\nimport { TowerFactory } from './Components/Towers/Towers';\r\nimport { Canvas } from './Components/Canvas';\r\nimport { CommandBar } from './Components/CommandBar';\r\nimport { Button } from './Components/BasicElements/Button';\r\nimport { Enemy } from './Components/Enemies/Enemy';\r\nimport { IWaveSettings } from './Models';\r\nimport { IButtonParams } from './Components/BasicElements/Models';\r\n\r\nconst defaultPath: Path = new Path([\r\n    {\r\n        x: 10,\r\n        y: 10,\r\n    },\r\n    {\r\n        x: 10,\r\n        y: 300,\r\n    },\r\n    {\r\n        x: 200,\r\n        y: 300,\r\n    },\r\n    {\r\n        x: 300,\r\n        y: 10,\r\n    },\r\n    {\r\n        x: 500,\r\n        y: 10,\r\n    },\r\n    {\r\n        x: 500,\r\n        y: 300,\r\n    },\r\n]);\r\n\r\nconst defaultTowers = [\r\n    TowerFactory.createTower(\r\n        {\r\n            x: 50,\r\n            y: 50,\r\n        },\r\n        TowerType.SpearTower,\r\n        1\r\n    ),\r\n    TowerFactory.createTower(\r\n        {\r\n            x: 100,\r\n            y: 250,\r\n        },\r\n        TowerType.SpearTower,\r\n        1\r\n    ),\r\n];\r\n\r\nexport class TowerDefenseGame {\r\n    private towers: ITower[] = defaultTowers;\r\n    private path: Path = defaultPath;\r\n    private enemies: Enemy[] = [];\r\n    private canvas: Canvas;\r\n    private intervalId?: NodeJS.Timeout;\r\n    private fps = 60;\r\n    private lifes = 7;\r\n    private waves: Map<number, IWaveSettings> = new Map([\r\n        [\r\n            1,\r\n            {\r\n                enemiesColor: 'blue',\r\n                enemiesMoveSpeed: 1,\r\n                enemiesNumber: 3,\r\n                spawnSpeed: 500,\r\n            },\r\n        ],\r\n        [\r\n            2,\r\n            {\r\n                enemiesColor: 'red',\r\n                enemiesMoveSpeed: 0.1,\r\n                enemiesNumber: 20,\r\n                spawnSpeed: 500,\r\n            },\r\n        ],\r\n        [\r\n            3,\r\n            {\r\n                enemiesColor: 'green',\r\n                enemiesMoveSpeed: 0.5,\r\n                enemiesNumber: 10,\r\n                spawnSpeed: 100,\r\n            },\r\n        ],\r\n        [\r\n            4,\r\n            {\r\n                enemiesColor: 'brown',\r\n                enemiesMoveSpeed: 0.5,\r\n                enemiesNumber: 200,\r\n                spawnSpeed: 300,\r\n            },\r\n        ],\r\n    ]);\r\n    private gameIsRunning = false;\r\n\r\n    private bottomRightButton: IButtonParams;\r\n\r\n    constructor(private htmlCanvas: HTMLCanvasElement) {\r\n        this.canvas = new Canvas(htmlCanvas);\r\n        this.bottomRightButton = {\r\n            buttonHeight: 50,\r\n            buttonWidth: 100,\r\n            leftTopX: this.canvas.size.width - 100,\r\n            leftTopY: this.canvas.size.height - 50,\r\n        };\r\n    }\r\n\r\n    public testMode(): void {\r\n        const commandBar = new CommandBar(this.canvas.size);\r\n        this.canvas.add(commandBar);\r\n        this.canvas.update();\r\n    }\r\n\r\n    public initialize(): void {\r\n        this.lifes = 7;\r\n        this.canvas = new Canvas(this.htmlCanvas);\r\n        this.enemies = [];\r\n        this.canvas.add(...this.towers, this.path);\r\n        this.showMainMenu();\r\n    }\r\n\r\n    private showMainMenu(): void {\r\n        const startButton = new Button(\r\n            `Start`,\r\n            () => {\r\n                this.canvas.remove(startButton);\r\n                this.canvas.update();\r\n                this.start();\r\n            },\r\n            this.bottomRightButton\r\n        );\r\n        this.canvas.add(startButton);\r\n        this.canvas.update();\r\n    }\r\n\r\n    private start(): void {\r\n        this.intervalId = setInterval(() => {\r\n            this.run();\r\n        }, 1000 / this.fps) as unknown as NodeJS.Timeout;\r\n        this.gameIsRunning = true;\r\n        this.startLevel(1);\r\n    }\r\n\r\n    private async startLevel(level: number): Promise<void> {\r\n        if (this.gameIsRunning) {\r\n            const result = await this.startEnemiesSpawn(level);\r\n            if (result && this.gameIsRunning) {\r\n                if (level < this.waves.size) {\r\n                    const nextLevelButton = new Button(\r\n                        `Start level: ${++level}`,\r\n                        () => {\r\n                            this.canvas.remove(nextLevelButton);\r\n                            this.startLevel(level);\r\n                        },\r\n                        {\r\n                            ...this.bottomRightButton,\r\n                            buttonWidth: 150,\r\n                            leftTopX: this.canvas.size.width - 150,\r\n                        }\r\n                    );\r\n                    this.canvas.add(nextLevelButton);\r\n                } else {\r\n                    const playAgainMenu = new Button(\r\n                        'You won!',\r\n                        () => {\r\n                            this.canvas.remove(playAgainMenu);\r\n                            this.initialize();\r\n                        },\r\n                        this.bottomRightButton\r\n                    );\r\n                    this.canvas.add(playAgainMenu);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async startEnemiesSpawn(level: number): Promise<boolean> {\r\n        console.log('level: ', level);\r\n        let enemiesCounter = 1;\r\n        const levelConfigs = this.waves.get(level);\r\n        const spawnEnemy = () => {\r\n            const newEnemy = new Enemy(\r\n                this.path,\r\n                levelConfigs.enemiesMoveSpeed,\r\n                undefined,\r\n                levelConfigs.enemiesColor\r\n            );\r\n            this.enemies.push(newEnemy);\r\n            this.canvas.add(newEnemy);\r\n        };\r\n        spawnEnemy();\r\n        return new Promise((resolve, reject) => {\r\n            const enemySpawnInterval = setInterval(() => {\r\n                if (enemiesCounter >= levelConfigs.enemiesNumber) {\r\n                    if (enemySpawnInterval) {\r\n                        clearInterval(enemySpawnInterval);\r\n                    }\r\n                    resolve(true);\r\n                    return;\r\n                }\r\n                spawnEnemy();\r\n                enemiesCounter++;\r\n                if (!this.gameIsRunning) {\r\n                    if (enemySpawnInterval) {\r\n                        clearInterval(enemySpawnInterval);\r\n                    }\r\n                    resolve(false);\r\n                }\r\n            }, levelConfigs.spawnSpeed);\r\n        });\r\n    }\r\n\r\n    private run(): void {\r\n        this.enemies.forEach((x) => {\r\n            const reachedFinish = x.moveForward();\r\n            if (reachedFinish) {\r\n                this.lifes--;\r\n                this.enemies = this.enemies.filter((y) => y !== x);\r\n                console.log('lifes: ', this.lifes);\r\n                if (this.lifes <= 0) {\r\n                    this.stop();\r\n                    const gameOverMenu = new Button(\r\n                        'Game over',\r\n                        () => {\r\n                            this.canvas.remove(gameOverMenu);\r\n                            this.initialize();\r\n                        },\r\n                        this.bottomRightButton\r\n                    );\r\n                    this.canvas.add(gameOverMenu);\r\n                }\r\n            }\r\n        });\r\n        this.towers.forEach((x) => x.attack(this.enemies));\r\n        this.canvas.update();\r\n    }\r\n\r\n    private stop(): void {\r\n        if (this.intervalId) {\r\n            clearInterval(this.intervalId);\r\n        }\r\n        this.gameIsRunning = false;\r\n    }\r\n}\r\n"],"names":["defaultBlockSize","logsElId","toggleLogsButtonId","canvasId","TowerType","points","color","percentPathMap","Map","length","this","calculateSections","index","point","prevPoint","start","Math","abs","x","y","set","end","getPointAtPercent","percent","step","sectionKey","Array","from","keys","find","section","get","sectionPercent","dx","dy","X","Y","round","draw","ctx","save","fillStyle","beginPath","setLineDash","lineCap","moveTo","lineTo","stroke","restore","drawStartEnd","arc","fill","closePath","pointInsideRect","rectCenter","size","xInside","width","yInside","pointInsideCircle","circleCenter","radius","sqrt","position","blockSize","leftTopX","leftTopY","Error","createTower","type","level","SpearTower","towerParams","damageStart","damageEnd","attackRange","attackSpeed","SplashTower","getTowerParams","SpearTowerBase","params","attackCounter","min","max","random","onClickHandler","pointInPath","isPointInPath","path","Path2D","drawAttackRange","attack","enemies","enemy","dead","PointHelper","shootAt","damage","Item","logsEl","document","getElementById","htmlCanvas","emptyColor","items","_dragNDropDisabled","addEventListener","ev","handleMousedown","handleTouchstart","handleMousemove","handleTouchmove","handleMouseup","handleTouchend","handleMouseClicks","setSize","height","DisableDragNDrop","EnabledDragNDrop","offsetX","offsetY","dragItem","undefined","filter","msg","touchPoint","touches","pageX","offsetLeft","pageY","offsetTop","JSON","stringify","innerHTML","handleOnClick","coords","update","_ev","getContext","add","push","remove","includes","clearRect","forEach","canvasSize","barHeight","fillRect","drawMenuItems","text","onClick","buttonHeight","buttonWidth","radgrad","createRadialGradient","addColorStop","rect","font","textAlign","textBaseline","fillText","dmg","target","progress","speed","moveForward","targetPosition","moveSpeed","_dead","_healthPoints","projectiles","towerPosition","Projectile","doDamage","reachedProjectiles","nextPoint","defaultPath","Path","defaultTowers","TowerFactory","towers","fps","lifes","waves","enemiesColor","enemiesMoveSpeed","enemiesNumber","spawnSpeed","gameIsRunning","canvas","Canvas","bottomRightButton","testMode","commandBar","CommandBar","initialize","showMainMenu","startButton","Button","intervalId","setInterval","run","startLevel","startEnemiesSpawn","console","log","enemiesCounter","levelConfigs","spawnEnemy","newEnemy","Enemy","Promise","resolve","reject","enemySpawnInterval","clearInterval","stop"],"sourceRoot":""}